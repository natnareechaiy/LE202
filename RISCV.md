# อธิบายการทำงาน
## การทำงานของคำสั่ง
### คำสั่งที่ 1 addi x1, x0, 32
    เรียกคำสั่งจาก addr00000000 มาเรียงใหม่จะได้ data เป็น 02000093 หลังจากนั้นจะถูกส่งไปที่ Instruction reg. เพื่อแปลคำสั่ง นั่นคือเป็นการนำ 32 มาบวกกับ x0
    และแทนค่าลงไปที่ x1 หลังจากนั้นส่งไปดำเนินการต่อที่ ALU จาก x1 = 00000000 จะเป็น 00000020
### คำสั่งที่ 2 lui x2, 0xc0000000
    เรียกคำสั่งจาก addr00000004 มาเรียงใหม่จะได้ data เป็น c0000137 หลังจากนั้นจะถูกส่งไปที่ Instruction reg. เพื่อแปลคำสั่ง นั่นคือส่ง c0000000 ไปยัง x2 20 บิต
    จากนั้นส่งไปดำเนินการต่อ ซึ่งจากที่ x2 = 00000000 จะกลายเป็น c0000000
### คำสั่งที่ 3 lbu x3, 0(x1)
    เรียกคำสั่งจาก addr00000008 มาเรียงใหม่จะได้ data เป็น 000c183 หลังจากนั้นจะถูกส่งไปที่ Instruction reg. เพื่อแปลคำสั่ง ซึ่งจะได้ว่าโหลด 1 ไบต์ จาก x1
    ที่ addr00000020 จากนั้นส่งไปดำเนินการ ซึ่งจะได้ x3 = 0000004e
### คำสั่งที่ 4 beq x3, x0, +16
    เรียกคำสั่งจาก addr0000000c มาเรียงใหม่จะได้ data เป็น 00018863 หลังจากนั้นจะถูกส่งไปที่ Instruction reg. เพื่อแปลคำสั่ง ซึ่งจะได้ว่า ถ้า x3 = x0 ให้กระโดดไป
    +16addr แต่ x3 ≠ x0 คำสั่งจึงเป็น false ทำให้ต้องไปที่คำสั่งต่อไป
### คำสั่งที่ 5 sb x3, 0(x2)
    เรียกคำสั่งจาก addr00000010 มาเรียงใหม่จะได้ data เป็น 00310023 หลังจากนั้นจะถูกส่งไปที่ Instruction reg. เพื่อแปลคำสั่ง นั่นคือการนำค่าใน x3 ไปแทนใน x2
    จากนั้นจะดำเนินการโดยการนำค่า x3 = 0000004e หรือ N ส่งไปที่ x2 = c0000000 จากนั้นหน้าจอแสดงผลจะแสดงตัว N ขึ้น
### คำสั่งที่ 6 addi x1, x1, 1
    เรียกคำสั่งจาก addr00000014 มาเรียงใหม่จะได้ data เป็น 00108093 หลังจากนั้นจะถูกส่งไปที่ Instruction reg. เพื่อแปลคำสั่ง นั่นคือการนำ x1 + 1 แล้วแทนค่ากลับ
    ไปยัง x1 ซึ่งจากเดิมที่ x1 = 00000020 จะเป็น 00000021
### คำสั่งที่ 7 jal x0, -16
    เรียกคำสั่งจาก addr00000018 มาเรียงใหม่จะได้ data เป็น ff1ff06f หลังจากนั้นจะถูกส่งไปที่ Instruction reg. เพื่อแปลคำสั่ง ซึ่งจะได้ว่าให้ถอยกลับไป 16addr ไปที่
    addr00000008
### ย้อนกลับไปที่คำสั่งที่ 3 lbu x3, 0(x1)
    เรียกคำสั่งจาก addr00000008 มาเรียงใหม่จะได้ data เป็น 000c183 หลังจากนั้นจะถูกส่งไปที่ Instruction reg. เพื่อแปลคำสั่ง ซึ่งจะได้ว่าโหลด 1 ไบต์ จาก x1
    ที่ addr00000021 จากนั้นส่งไปดำเนินการ คือ ส่ง 1 ไบต์แรก หรือ 00000043 ส่งไปที่ x3
### คำสั่งที่ 4 beq x3, x0, +16
    เรียกคำสั่งจาก addr0000000c มาเรียงใหม่จะได้ data เป็น 00018863 หลังจากนั้นจะถูกส่งไปที่ Instruction reg. เพื่อแปลคำสั่ง ซึ่งจะได้ว่า ถ้า x3 = x0 ให้กระโดดไป
    +16addr แต่ x3 ≠ x0 คำสั่งจึงเป็น false ทำให้ต้องไปที่คำสั่งต่อไป 
### คำสั่งที่ 5 sb x3, 0(x2)
    เรียกคำสั่งจาก addr00000010 มาเรียงใหม่จะได้ data เป็น 00310023 หลังจากนั้นจะถูกส่งไปที่ Instruction reg. เพื่อแปลคำสั่ง นั่นคือการนำค่าใน x3 ไปแทนใน x2
    จากนั้นจะดำเนินการโดยการนำค่า x3 = 00000043 หรือ C ส่งไปที่ x2 = c0000000 จากนั้นหน้าจอแสดงผลจะแสดงตัว C เพิ่มขึ้นมา กลายเป็น NC
### คำสั่งที่ 6 addi x1, x1, 1
    เรียกคำสั่งจาก addr00000014 มาเรียงใหม่จะได้ data เป็น 00108093 หลังจากนั้นจะถูกส่งไปที่ Instruction reg. เพื่อแปลคำสั่ง นั่นคือการนำ x1 + 1 แล้วแทนค่ากลับ
    ไปยัง x1 ซึ่งจากเดิมที่ x1 = 00000021 จะเป็น 00000022
### คำสั่งที่ 7 jal x0, -16
    เรียกคำสั่งจาก addr00000018 มาเรียงใหม่จะได้ data เป็น ff1ff06f หลังจากนั้นจะถูกส่งไปที่ Instruction reg. เพื่อแปลคำสั่ง ซึ่งจะได้ว่าให้ถอยกลับไป 16addr ไปที่
    addr00000008
### ย้อนกลับไปที่คำสั่งที่ 3 lbu x3, 0(x1)
    เรียกคำสั่งจาก addr00000008 มาเรียงใหม่จะได้ data เป็น 000c183 หลังจากนั้นจะถูกส่งไปที่ Instruction reg. เพื่อแปลคำสั่ง ซึ่งจะได้ว่าโหลด 1 ไบต์ จาก x1
    ที่ addr00000022 จากนั้นส่งไปดำเนินการ คือ ส่ง 1 ไบต์แรก หรือ 00000000 ส่งไปที่ x3 
### คำสั่งที่ 4 beq x3, x0, +16
    เรียกคำสั่งจาก addr0000000c มาเรียงใหม่จะได้ data เป็น 00018863 หลังจากนั้นจะถูกส่งไปที่ Instruction reg. เพื่อแปลคำสั่ง ซึ่งจะได้ว่า ถ้า x3 = x0 ให้กระโดดไป
    +16addr แต่ x3 = 00000000 = x0 จึงไปที่ addr0000001c
### คำสั่งที่ 8 jal x0, 0
    เรียกคำสั่งจาก addr0000001c มาเรียงใหม่จะได้ data เป็น 0000006f หลังจากนั้นจะถูกส่งไปที่ Instruction reg. เพื่อแปลคำสั่ง นั่นคือ จะวิ่งวนอยู่กับที่
## แสดงผล
![image](https://user-images.githubusercontent.com/98943909/160229556-734b5a81-1c21-4e3b-b47a-4f203b9f4b5a.png)

    
    
